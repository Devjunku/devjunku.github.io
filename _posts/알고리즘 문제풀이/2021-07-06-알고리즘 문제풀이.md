---
title:  "2021 KaKao BLIND RECRUITMENT 광고삽입"
excerpt: "문제해설"

categories:
  - Gitlog
tags:
  - [Gitlog, jekyll, Github, Git, Algorithm, KaKao]

toc: true
toc_sticky: true
 
date: 2021-07-06
last_modified_at: 2021-07-06
---


# 2021 KaKao BLIND RECRUITMENT
##### 광고 삽입 LEVEL3
##### 출처: [dev-note-97.tistory.com/156]()



이 문제 참.. 하.. 진짜 생각할수록 화나네요..
카페에서 몇시간 잡고 풀다가 집에 와서 다시 풀어보니까 22점 나왔네요..
대부분 시간 초과가 되었습니다.

풀이법을 살펴보니 가장 중요한 것은
시간(문자열) → 초단위(정수형) → 시간(문자열)
이렇게 변환하는 것이 아닌(이건 기본입니다..)
전체 방영시간을 초 단위로 쪼개어 리스트로 변환한 뒤 누적 방영 시간을 구하고
시작과 끝을 빼서 가장 큰 방영시간을 찾는 아이디어입니다.
(정사각형 방(SWEA) 문제의 아이디어와 비슷합니다.)

그리고 이를 memoization합니다. 왜 그렇게 하는지는 해당코드를 보면서 살펴봐야 이해하실겁니다.



1. 초 변환
``` python
def to_seconds(time): # 1번
    h, m, s = map(int, time.split(':'))
    return h * 3600 + m * 60 + s
```

2. 시간변환
```python
def to_time(time): # 2번
    h = str(time//3600).zfill(2) # 초를 시간으로 변환
    time = time % 3600 # 이건 분과 초를 합친 총합 초입니다.
    m = str(time//60).zfill(2) # 분 변환
    s = str(time%60).zfill(2) # 초 변환
    return ':'.join([h, m, s]) # 다시 합치기
```

2. 코드를 보았을 때 처음보는 메서드가 있을거에요. 아마?
`zfill` 메서드는 `zerofill`의 약어로 앞에 0을 채워주는 메서드입니다.
이와 비슷한 거로 `rjust`라는 메서드가 있어요.

예를 들어서
`"2".zfill(3)`은 "002"로 출력되고
`"123".zfill(5)`는 "00123"으로 출력됩니다.

그니까 괄호안에 수(n)은 n번째 자리까지 비어있는 숫자는 0으로 채워준다는 의미입니다.

그러면 만약에 `"50000".zfill(5)`는 "50000"으로 출력됩니다.
왜냐하면 이미 5자리 수이기 때문이죠.

문자열로 출력된다는건 잊지마시길!

``` python
def solution(play_time, adv_time, logs):
    answer = ''
    '''
    3. 모두 초로 변환합니다.
    '''
    play_time = to_seconds(play_time) # 3번
    adv_time = to_seconds(adv_time)

    '''
    4. 시청자 수를 기록할 리스트를 따로 만듭니다. 
       이걸로 초단위로 시청자수를 셀거에요.
       참고로 play-time을 계산했기 때문에 총 플레이 시간만큼
       메모 배열이 만들어진거에요.
       사실 이건 생각못했어요... 공간을 너무 먹을거 같은데? 라는 느낌이 오실거에요.
       근데 일단 쭉 가봅시다.
    '''
    memo = [0 for _ in range(play_time+1)] # 4번

    '''
    5. 로그의 시작 시간과 끝나는 시간에 각각 1과 -1을 더해줍니다.
       그 이유는 playtime을 전부다 돌거든요.. 그 때 처음부터 누적시키려면 처음은 1로 두고 마지막은 -1로 둬서
       시청자수를 구분 해줘야합니다.
    '''
    for l in logs: # 5번
        s, e = map(str, l.split('-'))
        s = to_seconds(s)
        e = to_seconds(e)

        memo[s] += 1
        memo[e] -= 1
    
    '''
    6, 7.   아래와 같이 한번 순회를 돌면 5번에 의해 기록되었던 로그의 시작 시간과 끝 시간에 의해
            특정 초에 시청한 사람의 수가 기록됩니다. 그리고 순회를 두 번 하면 그 시청자 수가 누적됩니다.
            예를 들어서 play_time의 초가 15라 하겠습니다.
            memo는 4번 코드에 의해 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 이렇게 됩니다.
            logs는 5번 코드에 의해 A: [3, 7], B: [5, 11], C: [9, 15]로 되어있다고 하면 memo는 다음과 같이 바뀝니다.
            (알파벳은 사람이라 생각하시면 됩니다.)
            memo = [0, 0, 0, 1, 0, 1, 0, -1 ,0 ,1 ,0 ,- 1, 0, 0, 0, -1] 이를 6번 코드를 실행하면 다음과 같이 바뀝니다.
            memo = [0, 0, 0, 1, 1, 2, 2, 1, 1, 2, 2, 1, 1, 1, 1, 0] 그리고 이를 한번 더 7번으로 가면
            memo = [0, 0, 0, 1, 2, 4, 6, 7, 8, 10, 12, 13, 14, 15, 16, 16] 이렇게 바뀝니다.
            도대체 이걸로 뭐 어떻게 할건데? 라는 생각이 드실텐데
            이걸 이제 어떻게 할지에 대한 자세한 계산은 10번 각주에서 확인 부탁드립니다.

            **이해를 돕기위한 첨언**
            대략적으로 말씀드리면 6번 코드로 인해 해당 시점에서 시청하는 시청자의 수를 알 수 있습니다.
            그리고 7번 코드로 인해 해당 시점에서 광고를 시청했던 시청자수를 누적하여 계산하므로
            해당 시점의 총 누적 방영 시간(초)이 됩니다.
            즉, 그 시점에서 시청한 시청자에 대한 방영 시간이 아니라
            그 시점까지 시청자에게 방영한 총 시간입니다.
            따라서 특정 시점(H1)과 특정 시점(H2)간의 차를 통해 원하는 구간에서 시청자에게
            광고를 방영한 시간을 알 수 있습니다.
    '''

    for i in range(1, play_time+1): # 6번
        memo[i] = memo[i] + memo[i-1]
        
    for i in range(1, play_time+1): # 7번
        memo[i] = memo[i] + memo[i-1]
    

    '''
    이제 광고 시간과 비교해서 문제에서 요구한 해당 시각을 계산할겁니다. 그전에
    최초 시작 가능한 광고시간과 끝나는 광고시간을 계산해주어야 합니다.
    '''

    '''
    8. 처음의 끝나는 시간은은 adv_time초에서 -1한 인덱스에서 끝날거에요.
    '''
    max_play = memo[adv_time-1] # 8번
    '''
    9. start는 당연히 0 인덱스겠죠
    '''
    start = 0 # 9번

    '''
    10, 11. 다시 순회를 돕니다. 순회는 광고 시간(초)과 총 영상 플레이 시간(초) 사이만 할겁니다.
            11번 코드부터 데이터 상에서 어떻게 나타나는지 시각적으로 확인하려면 광고시간이 필요하겠네요.
            광고시간은 5초라 하겠습니다. 예시에서 영상 플레이 시간은 총 15초로 지정했으니까 다음과 같이 나오겠네요.

            -1 번째 순회
            play: 4 = memo[5]: 4 - memo[5-5]: 0
            여기서 잠깐! 진짜로 계산해보면 광고가 0초에서 5초까지 방영되면 그 사이에 본 사람은 2명(A, B)이고
            실제 광고가 이 사람들에게 방영한 시간은 A: 3초, B: 1초로 총 4초입니다.
            
            이후 if 문에서 실제 방영된 시간(play)이 처음 지정한 시간(max_play)보다 크므로
            max_play를 업데이트 합니다.
            그리고 start를 해당 i에서 광고시간을 제외하고 1을 더합니다.
            따라서 max_play: 4, start:1로 업데이트 되고 start는 실제 광고 시작 시간(인덱스 아님)입니다.

            -2 번째 순회
            play: 6 = memo[6]: 6 - memo[6-5]: 0
            -1 번째 순회와 같이 계산되고 max_play와 start가 6과 2로 업데이트 됩니다.

            -3 번째 순회
            play: 7 = memo[7]: 7 - memo[7-5]: 0
            업데이트 됩니다.
            max_play: 7 start: 2

            -4 번째 순회
            play: 7 = memo[8]: 8 - memo[8-5]: 1
            업데이트 되지 않습니다.
            max_play: 7 start: 2

            -5 번째 순회
            play: 8 = memo[9]: 10 - memo[9-5]: 2
            업데이트 됩니다.
            max_play: 8 start: 5

            -6 번째 순회
            play: 8 = memo[10]: 12 - memo[10-5]: 4
            업데이트 되지 않습니다.
            max_play: 8 start: 5

            -7 번째 순회
            play: 7 = memo[11]: 13 - memo[11-5]: 6
            업데이트 되지 않습니다.
            max_play: 8 start: 5

            -8 번째 순회
            play: 7 = memo[12]: 14 - memo[12-5]: 7
            업데이트 되지 않습니다.
            max_play: 8 start: 5

            -9 번째 순회
            play: 5 = memo[13]: 15 - memo[13-5]: 10
            업데이트 되지 않습니다.
            max_play: 8 start: 5

            -10 번째 순회
            play: 6 = memo[14]: 16 - memo[14-5]: 10
            업데이트 되지 않습니다.
            max_play: 8 start: 5
    '''

    for i in range(adv_time, play_time): # 10번
        play = memo[i] - memo[i-adv_time] # 11번

        if play > max_play:
            max_play = play
            start = i - adv_time + 1

            '''
            11번 코드 이해하셨나요?
            이와 같은 방식으로 start는 5초에 방영하여
            총 8초 동안 시청자에게 최대로 방영된다는 것을
            알 수 있습니다.

            5초에 반영하면 A:[3, 7]에게 3초(5, 6, 7)를 B[5, 11]에게 5초(5, 6, 7, 8, 9)를 반영하는 것임.
            '''
        
    answer = to_time(start) # 12번 초시간 변동
    return answer
```


읽어주셔서 감사드리고,,,

이 풀이를 보고 생각든건.. 아마 영상들의 시작 시간을 기점으로 풀이를 시도하는건 잘못된 풀이이지 않나 생각드네요.
왜냐면 그 풀이는 초단위로 확인이 불가능하여 모든 경우를 고려하지 못한 풀이인거 같습니다.

```python
if __name__ == '__main__':
    print(solution("02:03:55", "00:14:15", ["01:20:15-01:45:14", "00:40:31-01:00:00", "00:25:50-00:48:29", "01:30:59-01:53:29", "01:37:44-02:02:30"]))
    print(solution("99:59:59", "25:00:00", ["69:59:59-89:59:59", "01:00:00-21:00:00", "79:59:59-99:59:59", "11:00:00-31:00:00"]))
    print(solution("50:00:00", "50:00:00", ["15:36:51-38:21:49", "10:14:18-15:36:51", "38:21:49-42:51:45"]))
```